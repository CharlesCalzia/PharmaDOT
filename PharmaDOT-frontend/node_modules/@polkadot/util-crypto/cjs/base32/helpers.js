"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createValidate = exports.createIs = exports.createEncode = exports.createDecode = void 0;
const util_1 = require("@polkadot/util");
/** @internal */
function createDecode({ coder, ipfs }, validate) {
    return (value, ipfsCompat) => {
        validate(value, ipfsCompat);
        return coder.decode(ipfs && ipfsCompat
            ? value.substring(1)
            : value);
    };
}
exports.createDecode = createDecode;
/** @internal */
function createEncode({ coder, ipfs }) {
    return (value, ipfsCompat) => {
        const out = coder.encode((0, util_1.u8aToU8a)(value));
        return ipfs && ipfsCompat
            ? `${ipfs}${out}`
            : out;
    };
}
exports.createEncode = createEncode;
/** @internal */
function createIs(validate) {
    return (value, ipfsCompat) => {
        try {
            return validate(value, ipfsCompat);
        }
        catch {
            return false;
        }
    };
}
exports.createIs = createIs;
/** @internal */
function createValidate({ chars, ipfs, type }) {
    return (value, ipfsCompat) => {
        if (typeof value !== 'string') {
            throw new Error(`Expected ${type} string input`);
        }
        else if (ipfs && ipfsCompat && value[0] !== ipfs) {
            throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
        }
        for (let i = (ipfsCompat ? 1 : 0); i < value.length; i++) {
            if (!(chars.includes(value[i]) || (value[i] === '=' && ((i === value.length - 1) ||
                !chars.includes(value[i + 1]))))) {
                throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
            }
        }
        return true;
    };
}
exports.createValidate = createValidate;
